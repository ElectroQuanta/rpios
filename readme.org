#+TITLE: RPi4 Baremetal
#+AUTHOR: Jos√© Pires
#+DATE: [2024-09-23 seg 16:53]
#+EMAIL: a50178@alunos.uminho.pt

#+LATEX_COMPILER: xelatex

* TOC :noexport::TOC_3:
- [[#preamble][Preamble]]
- [[#lesson-1-setup][Lesson 1: Setup]]
- [[#lesson-2-mini-uart--boot-code--hello-world][Lesson 2: Mini-UART + boot code + hello world]]
  - [[#mini-uart-setup][Mini-UART setup]]
  - [[#utils][utils]]
  - [[#memory-management][Memory management]]
  - [[#boots][=boot.S=]]
  - [[#kernelc][=kernel.c=]]
- [[#lesson-3-gpio][Lesson 3: GPIO]]
- [[#lesson-4-mini-uart-implementation][Lesson 4: Mini-UART implementation]]
- [[#lesson-5-deployment-and-testing][Lesson 5: Deployment and testing]]

* Preamble
- [[https://www.youtube.com/watch?v=pd9AVmcRc6U&list=PLVxiWMqQvhg9FCteL7I0aohj1_YiUx1x8][src]]
- [[https://github.com/s-matyukevich/raspberry-pi-os][Based on the Github tutorials]]

* Lesson 1: Setup

1) Install the Cross-compiler
   #+begin_src bash
	 sudo apt install gcc-aarch64-linux-gnu

	 aarch64-linux-gnu-gcc -v
	 Using built-in specs.
	 COLLECT_GCC=aarch64-linux-gnu-gcc
	 COLLECT_LTO_WRAPPER=/usr/lib/gcc/aarch64-linux-gnu/14.1.0/lto-wrapper
	 Target: aarch64-linux-gnu
	 Configured with: /build/aarch64-linux-gnu-gcc/src/gcc-14.1.0/configure --prefix=/usr --program-prefix=aarch64-linux-gnu- --with-local-prefix=/usr/aarch64-linux-gnu --with-sysroot=/usr/aarch64-linux-gnu --with-build-sysroot=/usr/aarch64-linux-gnu --with-native-system-header-dir=/include --libdir=/usr/lib --libexecdir=/usr/lib --target=aarch64-linux-gnu --host=x86_64-pc-linux-gnu --build=x86_64-pc-linux-gnu --disable-nls --enable-default-pie --enable-languages=c,c++,fortran --enable-shared --enable-threads=posix --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --disable-multilib --disable-werror --enable-checking=release
	 Thread model: posix
	 Supported LTO compression algorithms: zlib zstd
	 gcc version 14.1.0 (GCC)
   #+end_src
   - Or use the one from ARM toolchain

2) Create the =Makefile=
   1) Setup RPI version, boot mount and cross-compiler
   2) Define C and Assembly options for the compiler
   3) Setup directories: =SRC_DIR= and =BUILD_DIR=
   4) Targets:
	  1) all: create the kernel image
	  2) Generate object files from C source and ASM files and the associated
         dependencies
		 1) The dependencies are useful to instruct =make= on what targets have
            changed
	  3) Use the linker file to generate an ELF file
	  4) Generate a raw executable binary from the ELF file
	  5) Copy the kernel image and config.txt to SD card

3) Create a [[file:~/OneDrive_UM/Documents/Programming/Hardware/RaspberryPi/baremetal/rpios/include/base.h::pragma once][peripherals base header]] file to setup some relevant constants:
   1) =PBASE=: peripheral base; this value is extracted from the BCM2711
      datasheet or from the device tree ([[file:~/OneDrive_UM/Documents/Programming/Hardware/RaspberryPi/rpi3/doc/dts/bcm2711.dtsi::ranges = <0x7e000000 0x0 0xfe000000 0x01800000>,][bcm2711.dtsi]] file):
		#+begin_src c
		  #address-cells = <0x02>;
		  #size-cells = <0x01>;
		  soc {
			/*
			 ,* Defined ranges:
			 ,*   Common BCM283x peripherals
			 ,*   BCM2711-specific peripherals
			 ,*   ARM-local peripherals
			 ,*/
			ranges = <0x7e000000  0x0 0xfe000000  0x01800000>,
			  <0x7c000000  0x0 0xfc000000  0x02000000>,
			  <0x40000000  0x0 0xff800000  0x00800000>;
		#+end_src

	  1) The peripheral base is the first region, defined by =child-bus-address
         parent-bus-address length= 1). The =parent-bus-address= requires 2
         =address-cells= (root node, in this case)

		|-------------------+-----------------+------------|
		| Child-Bus-Address | Parent-Bus-Addr |     Length |
		|-------------------+-----------------+------------|
		|        0x7e000000 | 0x00 0xfe000000 | 0x18000000 |
		|-------------------+-----------------+------------|

* Lesson 2: Mini-UART + boot code + hello world

** Mini-UART setup
- Open BCM2835 peripherals, in the Auxiliaries secion
  - The Auxiliary peripherals named =AUX_MU_*= correspond to the Mini-UART


|-------------+-----------------+---------------------------+------|
| Address     | Register Name   | Description               | Size |
|-------------+-----------------+---------------------------+------|
| 0x7E21 5040 | AUX_MU_IO_REG   | M-Uart I/O Data           |    8 |
| 0x7E21 5044 | AUX_MU_IER_REG  | M-Uart Interrupt Enable   |    8 |
| 0x7E21 5048 | AUX_MU_IIR_REG  | M-Uart Interrupt Identify |    8 |
| 0x7E21 504C | AUX_MU_LCR_REG  | M-Uart Line Control       |    8 |
| 0x7E21 5050 | AUX_MU_MCR_REG  | M-Uart Modem Control      |    8 |
| 0x7E21 5054 | AUX_MU_LSR_REG  | M-Uart Line Status        |    8 |
| 0x7E21 5058 | AUX_MU_MSR_REG  | M-Uart Modem Status       |    8 |
| 0x7E21 505C | AUX_MU_SCRATCH  | M-Uart Scratch            |    8 |
| 0x7E21 5060 | AUX_MU_CNTL_REG | M-Uart Extra Control      |    8 |
| 0x7E21 5064 | AUX_MU_STAT_REG | M-Uart Extra Status       |   32 |
| 0x7E21 5068 | AUX_MU_BAUD_REG | M-Uart Baudrate           |   16 |
|-------------+-----------------+---------------------------+------|

We will create a struct to host the auxiliary Mini UART peripheral
#+begin_src c
struct AuxRegs {
  reg32 irq_status; /**< Auxiliary Interrupt status */
  reg32 enables; /**< Auxiliary enables */
  reg32 reserved[14]; // (0x5040 - 1 - (0x5004 + 3)) / 4
  reg32 mu_io;         /**< Mini UART I/O Data */
  reg32 mu_ier;        /**< Mini UART Interrupt Enable */
  reg32 mu_iir;        /**< Mini UART Interrupt Identify */
  reg32 mu_lcr;        /**< Mini UART Line Control */
  reg32 mu_mcr;        /**< Mini UART Modem Control */
  reg32 mu_lsr;        /**< Mini UART Line Status */
  reg32 mu_msr;        /**< Mini UART Modem Status */
  reg32 mu_scratch;    /**< Mini UART Scratch */
  reg32 mu_control;    /**< Mini UART Extra Control */
  reg32 mu_status;     /**< Mini UART Extra Status */
  reg32 mu_baud_rate;  /**< Mini UART Baudrate */
};

#define REGS_AUX ((struct AuxRegs *)(PBASE + 0x00215000))
#+end_src


We define the basic interface (header file) for the Mini UART:
#+begin_src c
void uart_init();
char uart_recv();
void uart_send(char c);
void uart_send_string(char *str);
#+end_src

** utils
Utils module support several utility functions used throughout the code.
- It contains an interface: =utils.h=
	#+begin_src c
	  /**
	   ,* @brief Create a delay for a nr of ticks
	   ,* @param ticks: nr of ticks to delay
	   ,*/
	  void delay(u64 ticks);

	  /**
	   ,* @brief Put a 32-bit value at a designated address
	   ,* @param val: 32-bit value to copy
	   ,* @param addr: address to copy the value from
	   ,*/
	  void put32(u64 addr, u32 val);

	  /**
	   ,* @brief Get a 32-bit value from a designated address
	   ,* @param address: address to get the value from
	   ,* @return 32-bit value
	   ,*/
	  u32 get32(u64 address);
	#+end_src
- and an implementation: =utils.s=

** Memory management
The =mm= module is responsible for managing the memory.

=mm.h=
#+begin_src c
#define PAGE_SHIFT 12
#define TABLE_SHIFT 9
#define SECTION_SHIFT (PAGE_SHIFT + TABLE_SHIFT)
#define PAGE_SIZE (1 << PAGE_SHIFT) // Page size
#define SECTION_SIZE (1 << PAGE_SHIFT) // Section size

#define LOW_MEMORY (2 * SECTION_SIZE)

/**< Make sure the functions below are only included in C compilations */
#ifndef __ASSEMBLER__
/**
 * @brief Clear the memory (zero it)
 * @param src: pointer to memory to clear
 * @param n: nr of bytes to clear
 */
//void memzero( unsigned long src, unsigned int n);
void memzero( u64 src, u32 n);
#endif
#+end_src

=mm.S=: implementation in Assembly

** =boot.S=
The =boot.S= is the startup code for our kernel, namely the =_start= label.
- We retrieve the CPU ID and if it's zero (master), we branch to the =master=
  label
- Else we hang the processor
- In the =master= section, we clear the memory the BSS (Block Started by Symbol)
  segment, which holds *uninitialized global and static variables*
- We set the stack pointer and jump to the kernel main, which should run forever
- Otherwise, we hang the processor, which basically means we go into a low-power
  mode (=wfe=) and loop forever


#+begin_src asm
#include "mm.h"

.section ".text.boot"

.global _start
_start: 
    mrs x0, mpidr_el1 // get CPU ID into x0
    and x0, x0, #0xFF // and it with 0xFF
    cbz x0, master // if CPU_ID == 0, we branch to master
    b proc_hang // else we branch to proc_hang (hanging the processor)

master: 
    adr x0, bss_begin // addr of BSS_BEGIN
    adr x1, bss_end // addr of BSS_END
    sub x1, x1, x0 // get the size of BSS = BSS_END - BSS_BEGIN
    bl memzero // zero it: memzero x0 x1

    mov sp, #LOW_MEMORY // set the SP to #LOW_MEMORY
    bl kernel_main // jump to kernel_main
    b proc_hang // hang the processor if we ever leave kernel_main

proc_hang:  
    wfe // wait for event
    b proc_hang
#+end_src

** =kernel.c=
This is our main function.
- We initialize the UART and send a welcome string alongside with the HW version
- Then we echo back anything the user types.

#+begin_src c
#include "mini_uart.h"

void kernel_main() {
  uart_init();
  uart_send_string("RPi Baremetal OS initializing...\n");

#if RPI_VERSION == 3
  uart_send_string("\tBoard: RPi 3\n");
#endif

#if RPI_VERSION == 4
  uart_send_string("\tBoard: RPi 4\n");
#endif

  uart_send_string("\n\nDone\n");

  while(1) {
	uart_send( uart_recv() );
  }
}
#+end_src

* Lesson 3: GPIO
We implemented two functions to:
1) Set the pin function
   - Get the bit start and register
     - We have 3 bits for each register
     - We have 10 pins per register
     - bit start = (pinNumber * GPIO_BITS ) % GPIO_BITS_TOTAL
     - register = pinNumber / GPIO_PINS_PER_REG;
   - Get the function selector, clear the bits and set the new function and
     update it
2) Enable the pin clock:
   1) Write to GPPUD to set the required control signal (Off)
   2) Wait 150 cycles: this provides the required setup time for the control
      signal
   3) Write to GPPUDCLK0/1 to clock the control signal into the GPIO pads you
      wish to modify
      1) GPPUDCLK0: for n = 0..31
      2) GPPUDCLK0: for n > 1
      3) GPPUDCLK[reg]: reg = n / 32
      4) Write the value 1 into CLK0/1
	 1) =1 << N=, where =N = pinNr % 32=
	 2) Shift left the bit 1 by N positions
	 3) Examples:
	    1) pinNr = 0 -> N = 0 -> 1 << 0 -> 0b01
	    1) pinNr = 1 -> N = 1 -> 1 << 1 -> 0b10
	    1) pinNr = 2 -> N = 0 -> 1 << 0 -> 0b100
   4) Wait 150 cycles: this provides the required hold time for the control
      signal
   5) Write to GPPUD to set the required control signal (Off)
   6) Write to GPPUDCLK0/1 to remove the clock

      
#+begin_src c
#define GPIO_BITS 3
#define GPIO_PINS_PER_REG 10
#define GPIO_BITS_TOTAL (GPIO_PINS_PER_REG * GPIO_BITS)

void gpio_pin_set_func(u8 pinNumber, GpioFunc func) {
  /* Get the bit start and register */
  u8 bitStart = (pinNumber * GPIO_BITS) % GPIO_BITS_TOTAL;
  u8 reg = pinNumber / GPIO_PINS_PER_REG;

  /* Store the current function to an auxiliary var */
  u32 selector = REGS_GPIO->func_select[reg];

  /* Set the new function in the aux */
  selector &= ~(0b111 << bitStart); // clear the 3 bits
  selector |= (func << bitStart); // Set the 3 bits to the new func

  /* Load the config back to the registor */
  REGS_GPIO->func_select[reg] = selector; 
}

/**
 * GPIO Pull-up/down Clock Registers (GPPUDCLKn)
 * SYNOPSIS
 * The GPIO Pull-up/down Clock Registers control the actuation of internal pull-downs on
 * the respective GPIO pins. These registers must be used in conjunction with the GPPUD
 * register to effect GPIO Pull-up/down changes. The following sequence of events is
 * required:
 * 1. Write to GPPUD to set the required control signal (i.e. Pull-up or Pull-Down or neither
 * to remove the current Pull-up/down)
 * 2. Wait 150 cycles ‚Äì this provides the required set-up time for the control signal
 * 3. Write to GPPUDCLK0/1 to clock the control signal into the GPIO pads you wish to
 * modify ‚Äì NOTE only the pads which receive a clock will be modified, all others will
 * retain their previous state.
 * 4. Wait 150 cycles ‚Äì this provides the required hold time for the control signal
 * 5. Write to GPPUD to remove the control signal
 * 6. Write to GPPUDCLK0/1 to remove the clock
 */
void gpio_pin_enable(u8 pinNumber){
  REGS_GPIO->pupd_enable = GPUD_Off;
  delay(150);
  REGS_GPIO->pupd_enable_clocks[pinNumber / 32] = 1 << (pinNumber % 32);
  delay(150);
  REGS_GPIO->pupd_enable = GPUD_Off;
  REGS_GPIO->pupd_enable_clocks[pinNumber / 32] = 0;
}
#+end_src

* Lesson 4: Mini-UART implementation
First, and foremost, I fixed some assembly errors that caused the compilation to
fail, namely:
- Assembly comments: in GNU Assembler the comments must be =/* */= for inline
  and multiline comments


[[file:src/mini_uart.c][mini_uart.c]] contains the Mini-UART implementation.
1) =void uart_init()=: Initialize the UART
   - Set the TXD and RXD pins to alternate function 5 (UART)
   - Enable the clocks for each pin
   - Configure the Mini UART:
	 - Enable the mini uart before doing any setup
	 - disable the control to manipulate extra flags
	 - Set the data size to 8-bits
	 - Clear modem signals (RTS low)
	 - Set the baudrate to 115200 bps
	 - Send some characters over to fix boot messages
2) The baudrate register is calculated with an auxiliary function: 
	#+begin_src c
	/**
	* @brief Calculate Baudrate register value
	* @param sysclk: system clock frequency (in Hz) [in]
	* @param baudrate: baud rate (in bps) [in]
	* @return register value
	*
	* BR_reg = sysclk / (8 * BR) - 1 (see BCM2835 Peripherals - MiniUART)
	*/
	u32 static inline calc_br_reg(u32 sysclk, u32 baudrate){
	return (sysclk / ( 8 * baudrate ) - 1);
	};
	#+end_src
3) Send a character over the UART
	#+begin_src c
	/**
	* Send a character through UART
	* - Wait until bit 5 from LSR_REG is empty (this mean the TX FIFO can
	*   accept at least one byte)
	* - Data written to IO_REG is put in the transmit FIFO
	*   (provided it is not full)
	*/
	void uart_send(char c) {
	while (!(REGS_AUX->mu_lsr & (1 << 5)))
		;

	REGS_AUX->mu_io = c;
	}
	#+end_src
4) Receive a character from UART
	#+begin_src c
	/**
	* Receive a character from UART
	* - Wait until a character is received: LSR_REG bit 1 is set
	* - Return a byte from the IO register
	*  - As the IO register is 32-bit we need to AND-it with 0xFF
	*/
	char uart_recv(){
	while (!(REGS_AUX->mu_lsr & (1 << 0)))
		;

	return REGS_AUX->mu_io & 0xFF;
	}
	#+end_src
5) Send a string over UART:
	#+begin_src c
	/**
	* Send a string
	* - While the NUL terminator is not found
	*  - Send the character
	*  - Increment the pointer to point to the next char
	*  - If a newline is found, send a CR before it
	*/
	void uart_send_string(char *str) {

	while(*str){
		if(*str == '\n'){
		uart_send('\r');
		}
	}
	uart_send(*str);
	str++;

	}
	#+end_src


A linker script ([[file:src/linker.ld][linker.ld]]) describes how the sections in the input files should
be mapped into the output file, and how to control the memory layout of the
file. ([[https://users.informatik.haw-hamburg.de/~krabat/FH-Labor/gnupro/5_GNUPro_Utilities/c_Using_LD/ldLinker_scripts.html][src]])
- The output file is the ELF file
- We need to set the boot code (=boot.S=) into the first region of the
  executable, which contains the symbol =_start= (this is implicitly our entry
  point; explicitly the linker script must contain =ENTRY(_start)=)
- We then place the code (=.text=), the read-only data (=.rodata=) and
  initialized read-write data (=.data=).
- We align the memory for the BSS segment and we define the =bss_begin= and
  =bss_end= symbols to allow the boot code (=boot.S=) to clear the data before
  running the program.
- We define the BSS segment which contains uninitialized data.

* Lesson 5: Deployment and testing
1) Download the RPi OS to bootstrap
   1) Use the =rpi-imager= to flash a RPiOS 64-bit Lite
   2) We need this to setup the firmware and bootloaders
	  1) Otherwise we would need U-boot
2) Creating a mounting point for the SD card (it must match =BOOTMNT= in the
   Makefile)
	#+begin_src bash
	sudo mkdir -p /run/media/zmp/bootfs
	#+end_src
3) Mount the SD card
	#+begin_src bash 
	lsblk
	sudo mount /dev/sda1 /run/media/zmp/bootfs/
	#+end_src
4) Build
	#+begin_src bash
	make && make clean
	#+end_src
5) Unmount the SD card and eject
	#+begin_src bash
	sudo umount /dev/sda1 && sudo eject /dev/sda
	#+end_src
6) Connect the USB-TTL cable to RPi4:
   1) GPIO6: GND (Black)
   2) GPIO8: TXD (White)
   3) GPIO10: RXD (Green)
7) Connect with =screen=
	#+begin_src bash
	sudo dmesg | tail -n 20 | grep tty 
	screen /dev/ttyUSB0 115200
	#+end_src
8) Power on the RPi
	#+begin_src bash
	MESS:00:00:04.922501:0: dtb_file 'bcm2711-rpi-4-b.dtb'
	MESS:00:00:04.930523:0: brfs: File read: /mfs/sd/bcm2711-rpi-4-b.dtb
	MESS:00:00:04.933768:0: Loaded 'bcm2711-rpi-4-b.dtb' to 0x100 size 0xd9fc
	MESS:00:00:04.954003:0: brfs: File read: 55804 bytes
	MESS:00:00:04.965824:0: brfs: File read: /mfs/sd/overlays/overlay_map.dtb
	MESS:00:00:04.993014:0: brfs: File read: 5255 bytes
	MESS:00:00:04.996166:0: brfs: File read: /mfs/sd/config.txt
	MESS:00:00:05.000487:0: brfs: File read: 81 bytes
	MESS:00:00:05.013031:0: brfs: File read: /mfs/sd/overlays/miniuart-bt.dtbo
	MESS:00:00:05.037206:0: Loaded overlay 'miniuart-bt'
	MESS:00:00:05.096379:0: brfs: File read: 1566 bytes
	MESS:00:00:05.099548:0: brfs: File read: /mfs/sd/cmdline.txt
	MESS:00:00:05.103592:0: Read command line from file 'cmdline.txt':
	MESS:00:00:05.109435:0: 'console=serial0,115200 console=tty1 root=PARTUUID=a3f161f3-02 rootfstype=ext4 fsck.repair=yes rootwait quiet init=/usr/lib/raspberrypi-sys-mods/firstboot cfg80211.ieee80211_regdom=PT systemd.run=/boot/firstrun.sh systemd.run_su
	MESS:00:00:05.253042:0: brfs: File read: 286 bytes
	MESS:00:00:05.256800:0: brfs: File read: /mfs/sd/kernel8-rpi4.img
	MESS:00:00:05.260540:0: Loaded 'kernel8-rpi4.img' to 0x200000 size 0x4e8
	MESS:00:00:05.266981:0: Kernel relocated to 0x80000
	MESS:00:00:05.271561:0: Device tree loaded to 0x2eff2100 (size 0xded8)
	MESS:00:00:05.279834:0: uart: Set PL011 baud rate to 103448.300000 Hz
	MESS:00:00:05.286885:0: uart: Baud rate change done...
	MESS:00:00:05.288908:0: uart: Baud rate change done...
	MESS:00:00:05.294513:0: gpioman: gpioman_get_pin_num: pin SDC

	RPi Baremetal OS initializing...
			Board: RPi 4


	Done
	#+end_src


